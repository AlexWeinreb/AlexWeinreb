[
  {
    "objectID": "posts/notepad_plus_plus_plugin/index.html",
    "href": "posts/notepad_plus_plus_plugin/index.html",
    "title": "Writing a Notepad++ plugin",
    "section": "",
    "text": "I am in the process of writing a plugin for Notepad++ to perform some biological operations. As I am not familiar with C++ and other compiled languages, I am taking some notes here about the process.\nNote, another approach that I haven’t tried but might be of interest to anyone reading this: there is a PythonScript plugin that may allow to do all of this in a much easier way.\n\nMotivation: Notepad++ for DNA sequences\nThe plugin provides a few functions to work with biological sequences, namely taking the reverse-complement of a DNA string, getting its protein translation, and finding the next ORF. Of course such functions are already available in plenty of specialized software (e.g. ApE or Benchling), so why add it to a unrelated application?\nI use dedicated DNA software regularly, but it tends to be quite rigid, accepting only DNA characters, no space, little formatting… which is a good thing, as it makes it safer and avoid typos. But sometimes I need more of a sketchpad, pasting fragments of DNA in different frames, along with bits of translations. Maybe looking at some sequence in different frames. Maybe looking at a BAM file and trying to find a barcode and UMI. In these cases, I’ve found Notepad++ very useful, in particular it has this great feature that, if I select a sequence, it will highlight all identical sequences (more flexible than the search function of ApE or Benchling). But it is slightly annoying to switch between windows whenever I want to check if a string is present in revcomp etc.\n\n\nTooling\nTo develop a plugin, the first step is to go to the corresponding page in the Notepad++ documentation.\nThere, you will find promises to develop your first plugin in less than 10 minutes, and that “Even your grandmom can do it!”, I believe this is true, assuming your grandmom is familiar with C++ and the Win32 API.\nSo let’s see how this works. First you need to work in a compiled language, that is able to use existing header files and produce a DLL. If your favorite language doesn’t do that, or if you have no idea what any of this means, I suggest to use with the classic C++.\nYou will need a development environment for C++, in particular a compiler and Windows header files. The easiest is to look up Microsoft Visual Studio, and download the (free) Community Edition. Careful, the naming is confusing: you don’t want “Visual Studio Code”, which is a different program. From the website, you can only download an installer, and from there you can download the full Community edition (note that it is several GB). In addition, you will want to download the C++ bundle which contains important build tools.\nSeparately, you can open the plugin development section of the Notepad++ user manual, and download the plugin template source code.\n\n\nEditing the plugin template\nOnce Visual Studio is fully installed, we start open our project. Make a copy of the plugin template with the appropriate name and path. This contains two subdirectories, src, for your source code, and vs.proj, containing information for Visual Studio. In particular, the file vs.proj/NppPluginTemplate.vcxproj can be opened in Visual Studio.\nThe files to edit are in src. Two files need to be edited:\n\nPluginDefinition.cpp is where you define your actual plugin functions\nPluginDefinition.h is where you declare the functions\nNppPluginDemo.rc declares some general information (e.g. plugin name and version)\n\nAs far as I can tell, you won’t need to edit any other file in there. I added a README.md and a LICENSE for Github. If you download the plugin demo you can see how they added a resource folder and resource.h file.\n\n\nCompiling the plugin\nBefore going any further, we might want to check our configuration. Download the plugin demo and open it in Visual Studio. In the toolbar on top of the screen, you should see a menu such as this one:\n\nThe first field is to select the type of compilation: while developing, “Debug” gives you more information about the errors and log messages. When you have a satisfying version of your code, select “Release” to compile an optimized program, that gives less information about what’s happening.\nThe second menu is the architecture to compile for. It needs to match the version of Notepad++ installed: if you have the 32 bits version, compile “x86”, if you have the 64 bits, compile as “x86”. On a final version, you may want to compile for both architectures and make the binaries available on Github.\nFinally, the “Play” symbol starts the compilation. Click it having selected the appropriate parameters. If everything goes well, you will get an error message along the lines of:\n\nUnable to start ‘C:\\path\\to\\PluginDemo.dll’.\nC:\\path\\to\\PluginDemo.dll is not a valid Win32 application.\n\nIndeed, our plugin is not expected to be a valid standalone application, it’s just a dll that can be loaded by another application (Notepad++).\nOpen the directory of your plugin, in vs.proj a new subdirectory has been created, containing the newly compiled binary.\nAll that’s left to do is to install this plugin by copy/pasting it in the appropriate directory. Don’t forget to close Notepad++ before pasting. Then, when you re-open Notepad++, your new plugin should have appeared in the “Plugins” menu.\n\n\nPreparing to write a first function\nNow let’s start to work on a real plugin. As indicated in the manual, we start by opening PluginDefinition.h. We define the plugin name:\n//-------------------------------------//\n//-- STEP 1. DEFINE YOUR PLUGIN NAME --//\n//-------------------------------------//\n// Here define your plugin name\n//\nconst TCHAR NPP_PLUGIN_NAME[] = TEXT(\"Biotools for NPP\");\nAnd we define the number of functions, let’s start with just one:\n//-----------------------------------------------//\n//-- STEP 2. DEFINE YOUR PLUGIN COMMAND NUMBER --//\n//-----------------------------------------------//\n//\n// Here define the number of your plugin commands\n//\nconst int nbFunc = 1;\nA bit below that, we need to indicate the name of the functions:\n//\n// Your plugin command functions\n//\nvoid revcomp();\nNow we can switch to the file PluginDefinition.cpp.\n//--------------------------------------------//\n    //-- STEP 3. CUSTOMIZE YOUR PLUGIN COMMANDS --//\n    //--------------------------------------------//\n    // with function :\n    // setCommand(int index,                      // zero based number to indicate the order of command\n    //            TCHAR *commandName,             // the command name that you want to see in plugin menu\n    //            PFUNCPLUGINCMD functionPointer, // the symbol of function (function pointer) associated with this command. The body should be defined below. See Step 4.\n    //            ShortcutKey *shortcut,          // optional. Define a shortcut to trigger this command\n    //            bool check0nInit                // optional. Make this menu item be checked visually\n    //            );\n    setCommand(0, TEXT(\"Reverse-Complement\"), revcomp, NULL, false);\nThe first command has an index of 0, and will call the function revcomp(). Note that this only compiles if revcomp() has been declared in the header file (PluginDefinition.h), otherwise the compiler won’t know this is a correct function name.\nAnd we arrive at this part, where we can finally start writing our actual functions:\n//----------------------------------------------//\n//-- STEP 4. DEFINE YOUR ASSOCIATED FUNCTIONS --//\n//----------------------------------------------//\n\n\nThe Notepad++ and Scintilla APIs\nNow things get a bit more specific. To interact with Notepad++, you can use the API calls listed here. However, the main editor window is actually not directly controlled by Notepad++, it’s piloted by Scintilla, so you can interact with it using the API calls listed there.\nFinally, as indicated in the Notepad++ documentation, these calls have to be made using Window’s SendMessage API, and will have the form:\nLRESULT SendMessage(\n  [in] HWND   hWnd,\n  [in] UINT   Msg,\n  [in] WPARAM wParam,\n  [in] LPARAM lParam\n);\nwhere hWnd is a handle to the Notepad++ or Scintilla program we are sending the message to, Msg is the name of the command to execute (fron the documentations linked above), and wParam and lParam and parameters explained by the documentation.\nLet’s make a concrete example. For my function revcomp(), I expect the user to select a text and call the plugin. The plugin needs to get the selected text, do some processing, and replace it with a modified text. So how do we get the selected text? As this is happening inside the editor window, we look at the Scintilla API, and find SCI_GETSELTEXT:\n\nSCI_GETSELTEXT(, char *text NUL-terminated) → position This copies the currently selected text and a terminating NUL(0) byte to the text buffer. The buffer size should be determined by calling with a NULL pointer for the text argument: 1 + SCI_GETSELTEXT(0, NULL). This allows for rectangular and discontiguous selections as well as simple selections. See Multiple Selection for information on how multiple and rectangular selections and virtual space are copied.\n\nSo, we need to write\nSendMessage(scintillaHandle, SCI_GETSELTEXT, whatever, ptr)\nwhere whatever will be ignored, and ptr is a pointer to a buffer in which the selected text will be written.\nHere we have an additional difficulty: we need to initialize this buffer, and it needs to be long enough. So, as indicated in the doc, we will call this function twice, first using “a NULL pointer for the text argument”, and a second time with an appropriate pre-initialized buffer.\nWe can thus write this function:\nstd::string getSelectedText(HWND scintillaHandle)\n{\n    std::string selectedText;\n\n    \n    // Determine the buffer size needed for the selected text\n    LPARAM length = ::SendMessage(scintillaHandle, SCI_GETSELTEXT, 0, (LPARAM)nullptr);\n\n    if (length &gt; 0)\n    {\n        char* buffer = new char[length + 1];\n        buffer[0] = '\\0'; // Ensure the buffer is null-terminated\n\n        // Retrieve the selected text\n        ::SendMessage(scintillaHandle, SCI_GETSELTEXT, 0, (LPARAM)buffer);\n        selectedText = buffer;\n        delete[] buffer;\n    }\n    else {\n        selectedText = \"\";\n    }\n\n    return selectedText;\n}\nSome notes. First, I call ::SendMessage() to indicate that this is a function in the global namespace, and it doesn’t get overwritten. This appears to be the accepted good practice in this context.\nAs the first parameter of SCI_GETSELTEXT (the wParam) is ignored, I use 0 here.\nWhen determining the buffer size, I can use the nullptr that already exists in C++ to define a NULL pointer. I will cast it into an LPARAM to make sure the type checker doesn’t complain.\nOne part that this function doesn’t address is the scintillaHandle. How can I call this function? For this, we must turn to the Notepad++ interface, where we find NPPM_GETCURRENTSCINTILLA:\n\n[2028] NPPM_GETCURRENTSCINTILLA\nRetrieves the current Scintilla view\nParameters:\nwParam [in] int, must be zero. lParam [out]\nint * currentEdit, pointer to the buffer receiving the current view. The returned value can be one of the following:\n\n  Value        Meaning\n    0          The main view\n    1          The second view\n   -1          In case of an error\nReturn value:\nReturns always True\n\nSo we got it, we need to call:\n::SendMessage(nppData._nppHandle, NPPM_GETCURRENTSCINTILLA, 0, (LPARAM)&which);\nWhere the nppData._nppHandle is defined by Notepad++ and contain its handle, wParam = 0 as indicated by the documentation, and we give a pointer to which to store the Scintilla handle. To check for error, we can initialize which to a meaningless value, and select the handle based on the value of which:\nint which = -1;\n::SendMessage(nppData._nppHandle, NPPM_GETCURRENTSCINTILLA, 0, (LPARAM)&which);\nif (which == -1)\n    return ;\n\nHWND scintillaHandle = (which == 0) ? nppData._scintillaMainHandle : nppData._scintillaSecondHandle;\n\n\nstd::string selection = getSelectedText(scintillaHandle);\n\n\nRuntime debugging\nThere are three types of bugs: those that are detected directly by Visual Studio (typically syntax errors), and that appear underlined in red; those that are caught during compilation; and finally bugs that only manifest at runtime.\nTo help debug this last category, you can output some debugging information (the so-called print-based debugging). One way is to insert the information as text in the editor window (e.g. using SCI_REPLACESEL), or open a dialog box. The more “correct” way is to use debugging messages with OutputDebugString(). The problem now is, we have a dll, so Visual Studio can not directly run our code.\nThe solution is to first open Notepad++ with the plugin loaded, then in Visual Studio, use the menu Debug&gt;Attach to Process, and attach the running Notepad++. You can now interact with the open Window, and any debugging messages are printed in Visual Studio.\n\n\nAdditional remarks\nFirst, as I am not experienced with C++ you should probably not trust me.\nWhen closing Visual Studio, you get offered to save a “.sln” file, you can say yes, it saves the state of the program (e.g. currently open documents).\nThe best way to figure out how to do something is to look on Github or Sourceforge at other plugins.\nTo create a new function, you need to edit 4 places, in the header file (number of functions, signature of your new function) and the cpp file (in the menu, and to write the actual function).\n\n\nConclusions\nMy (badly written) plugin can be found on Github. Writing C++ code was an interesting (though confusing) experience, I would need a lot more practice to write anything close to good quality code.\nAs the plugin has reached a level of functionality that is good enough for my needs, I don’t intend to work more on it; however there could be useful improvements, for example to accept whitespace in the input (and either keep it as-is for the reverse-complement and next ORF, or remove it if inside a codon for translation)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AlexWeinreb",
    "section": "",
    "text": "Writing a Notepad++ plugin\n\n\n\n\n\n\n\nprogramming\n\n\n\n\n\n\n\n\n\n\n\nNov 9, 2023\n\n\nAlexis Weinreb\n\n\n\n\n\n\n  \n\n\n\n\nMost studied worm neuronal genes\n\n\n\n\n\n\n\nworm\n\n\nR\n\n\n\n\n\n\n\n\n\n\n\nNov 5, 2023\n\n\nAlexis Weinreb\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/most_studied_genes/index.html",
    "href": "posts/most_studied_genes/index.html",
    "title": "Most studied worm neuronal genes",
    "section": "",
    "text": "What genes are the most studied in worms? Wormbase’s comprehensive curation can help us answer that."
  },
  {
    "objectID": "posts/most_studied_genes/index.html#data-loading",
    "href": "posts/most_studied_genes/index.html#data-loading",
    "title": "Most studied worm neuronal genes",
    "section": "Data loading",
    "text": "Data loading\nThe first step is to read the data into R, we also rename the columns for names that are easier to work with. And if you look through the data, you may notice a number of genes do not have references associated (marked as “N.A.”), we need to ensure this is registered correctly.\n\nsuppressPackageStartupMessages(library(tidyverse))\n\nsimplemine_results &lt;- read_tsv(\"data/simplemine_results.txt\",\n                               col_types = \"ccccc\",\n                               na = \"N.A.\") |&gt;\n  select(gene_id = `WormBase Gene ID`,\n         gene_name = `Public Name`,\n         expr_pattern = `Expr_pattern Tissue`,\n         references = Reference)\n\nsimplemine_results\n\n# A tibble: 49,541 × 4\n   gene_id        gene_name expr_pattern                              references\n   &lt;chr&gt;          &lt;chr&gt;     &lt;chr&gt;                                     &lt;chr&gt;     \n 1 WBGene00000001 aap-1     body wall musculature, hypodermis, intes… WBPaper00…\n 2 WBGene00000002 aat-1     excretory cell, excretory gland cell, go… WBPaper00…\n 3 WBGene00000003 aat-2     &lt;NA&gt;                                      WBPaper00…\n 4 WBGene00000004 aat-3     &lt;NA&gt;                                      WBPaper00…\n 5 WBGene00000005 aat-4     &lt;NA&gt;                                      WBPaper00…\n 6 WBGene00000006 aat-5     &lt;NA&gt;                                      WBPaper00…\n 7 WBGene00000007 aat-6     intestine                                 WBPaper00…\n 8 WBGene00000008 aat-7     &lt;NA&gt;                                      WBPaper00…\n 9 WBGene00000009 aat-8     &lt;NA&gt;                                      WBPaper00…\n10 WBGene00000010 aat-9     body wall musculature, neuron             WBPaper00…\n# ℹ 49,531 more rows\n\n\nIn this format, the references are all packed in a single long string. We can count how many there are by relying on the consistent format. We just need to handle the case of references being “NA”. R would interpret it as “some unknown number of references”, but we know this actually means “no reference”.\n\npapers_per_gene &lt;- simplemine_results |&gt;\n  mutate(nb_papers = str_count(references, \"WBPaper\\\\d{8}\"),\n         nb_papers = if_else(is.na(references), 0, nb_papers)) |&gt;\n  arrange(desc(nb_papers))\n\npapers_per_gene\n\n# A tibble: 49,541 × 5\n   gene_id        gene_name expr_pattern                    references nb_papers\n   &lt;chr&gt;          &lt;chr&gt;     &lt;chr&gt;                           &lt;chr&gt;          &lt;dbl&gt;\n 1 WBGene00000912 daf-16    AIYL, AIYR, anterior distal ti… WBPaper00…      1675\n 2 WBGene00000898 daf-2     ADFL, ADFR, amphid neuron, ASH… WBPaper00…      1543\n 3 WBGene00001609 glp-1     AB, AB lineage cell, ABa, ABal… WBPaper00…       838\n 4 WBGene00000417 ced-3     ABaraapapaa, ABaraapapaad, ABa… WBPaper00…       724\n 5 WBGene00004804 skn-1     AB, ABa, ABp, AIYL, AIYR, ante… WBPaper00…       695\n 6 WBGene00003001 lin-12    ABplaaa, ABplpapp, ccDL, ccDR,… WBPaper00…       685\n 7 WBGene00000090 age-1     accessory cell, amphid neuron,… WBPaper00…       595\n 8 WBGene00002335 let-60    AIMR, AIYR, anchor cell, anter… WBPaper00…       566\n 9 WBGene00006789 unc-54    anal depressor muscle, anal sp… WBPaper00…       562\n10 WBGene00000418 ced-4     anal sphincter muscle, apoptot… WBPaper00…       502\n# ℹ 49,531 more rows\n\n\nAlternatively, an approach that is less efficient here, but maybe more general, is to make it one row per reference and count the number of rows for a given gene.\n\npapers_per_gene2 &lt;- simplemine_results |&gt;\n  separate_rows(references, sep = \",\") |&gt;\n  filter(!is.na(references)) |&gt;\n  group_by(gene_id, gene_name) |&gt;\n  summarize(nb_papers = n(),\n            .groups = \"drop\") |&gt;\n  arrange(desc(nb_papers))\n\nall.equal(papers_per_gene |&gt;\n            filter(! is.na(references)) |&gt;\n            select(-expr_pattern, -references),\n          papers_per_gene2)\n\n[1] TRUE\n\n\nLooking at the top genes, perhaps unsurprisingly, the 2 most studied genes in worms are daf-2 and daf-16. Then we see a lot more genes that also appear widely cited. Let’s look at the distribution to see if we can identify distinct categories.\n\nggplot(papers_per_gene) +\n  geom_histogram(aes(x=nb_papers), bins = 100, color = \"white\") +\n  theme_classic() +\n  scale_x_continuous(n.breaks = 10) +\n  scale_y_continuous(trans = \"log1p\", breaks = c(0,3,10,30,100,300,1000,3000,10000)) +\n  xlab(\"Number of papers\") + ylab(\"Number of genes\")\n\n\n\n\nSo categories we could distinguish are:\n\ngenes with more than 250 papers, that appeared at the top of the list\ngenes with many papers (let’s take &gt; 20)\ngenes with few or no papers\n\nWe can visualize these cutoffs on the histogram:\n\nggplot(papers_per_gene) +\n  geom_histogram(aes(x=nb_papers), bins = 500) +\n  theme_classic() +\n  scale_x_continuous(n.breaks = 10) +\n  scale_y_continuous(trans = \"log1p\", breaks = c(0,3,10,30,100,300,1000,3000,10000)) +\n  xlab(\"Number of papers\") + ylab(\"Number of genes\") +\n  geom_vline(aes(xintercept = 20), color = \"red3\") +\n  geom_vline(aes(xintercept = 250), color = \"green4\")\n\n\n\n\nIt might help to visualize the x axis on a log scale:\n\nggplot(papers_per_gene) +\n  geom_histogram(aes(x=nb_papers), bins = 500) +\n  theme_classic() +\n  scale_x_continuous(trans = \"log1p\", breaks = c(0, 10, 20, 50, 100, 250, 1000)) +\n  scale_y_continuous(trans = \"log1p\", breaks = c(0,3,10,30,100,300,1000,3000,10000)) +\n  xlab(\"Number of papers\") + ylab(\"Number of genes\") +\n  geom_vline(aes(xintercept = 20), color = \"red3\") +\n  geom_vline(aes(xintercept = 250), color = \"green4\")\n\n\n\n\nLooking at this graph, maybe a cutoff of 50 genes would be more appropriate than 20. But from domain knowledge, 50 seems too high a cutoff: would we really call a gene with 25 papers poorly studied?\nWe can look at the number of genes in each category:\n\npapers_per_gene |&gt;\n  mutate(category = cut(nb_papers,\n                        breaks = c(-1, 3, 20, 250, Inf),\n                        labels = c(\"unstudied\", \"lowly\",\"medium\",\"highly\"))) |&gt; \n  summarize(nb_genes = n(),\n            .by = category)\n\n# A tibble: 4 × 2\n  category  nb_genes\n  &lt;fct&gt;        &lt;int&gt;\n1 highly          59\n2 medium        1308\n3 lowly         4602\n4 unstudied    43572\n\n\nSo, there are 59 highly studied genes, and another 1308 well-studied genes. Let’s take a closer look at these most cited genes.\n\npapers_per_gene |&gt;\n  filter(nb_papers &gt;= 250) |&gt;\n  pull(gene_name)\n\n [1] \"daf-16\"  \"daf-2\"   \"glp-1\"   \"ced-3\"   \"skn-1\"   \"lin-12\"  \"age-1\"  \n [8] \"let-60\"  \"unc-54\"  \"ced-4\"   \"daf-12\"  \"let-23\"  \"daf-7\"   \"let-7\"  \n[15] \"mab-5\"   \"unc-6\"   \"egl-1\"   \"tra-1\"   \"fem-3\"   \"lin-4\"   \"ced-9\"  \n[22] \"tra-2\"   \"unc-13\"  \"unc-22\"  \"lin-14\"  \"gld-1\"   \"lin-3\"   \"mec-4\"  \n[29] \"mpk-1\"   \"sod-3\"   \"goa-1\"   \"rol-6\"   \"unc-5\"   \"lin-15B\" \"lin-39\" \n[36] \"par-3\"   \"daf-4\"   \"glr-1\"   \"pop-1\"   \"unc-40\"  \"ced-10\"  \"lin-15A\"\n[43] \"par-2\"   \"pie-1\"   \"fem-1\"   \"unc-104\" \"clk-1\"   \"hsf-1\"   \"unc-4\"  \n[50] \"ced-1\"   \"egl-5\"   \"par-1\"   \"lin-28\"  \"myo-3\"   \"tax-4\"   \"unc-86\" \n[57] \"lin-17\"  \"unc-29\"  \"her-1\""
  },
  {
    "objectID": "posts/most_studied_genes/index.html#by-tissue-type",
    "href": "posts/most_studied_genes/index.html#by-tissue-type",
    "title": "Most studied worm neuronal genes",
    "section": "By tissue type",
    "text": "By tissue type\nLet’s say I’m more interested in neuronal genes that are highly studied. One way to implement such a restriction is to look at which tissue each gene is supposedly expressed in.\n\nsimplemine_results |&gt;\n  mutate(is_neuronal = str_detect(expr_pattern, \"neuron\")) |&gt;\n  filter(is_neuronal) |&gt;\n  separate_rows(references, sep = \",\") |&gt;\n  filter(!is.na(references)) |&gt;\n  group_by(gene_id, gene_name) |&gt;\n  summarize(nb_papers = n(),\n            .groups = \"drop\") |&gt;\n  arrange(desc(nb_papers)) |&gt;\n  filter(nb_papers &gt;= 250) |&gt;\n  select(gene_name, nb_papers) |&gt;\n  knitr::kable()\n\n\n\n\ngene_name\nnb_papers\n\n\n\n\ndaf-16\n1675\n\n\ndaf-2\n1543\n\n\nglp-1\n838\n\n\nskn-1\n695\n\n\nlin-12\n685\n\n\nage-1\n595\n\n\nlet-60\n566\n\n\nced-4\n502\n\n\ndaf-12\n496\n\n\nlet-23\n490\n\n\ndaf-7\n455\n\n\nlet-7\n447\n\n\nmab-5\n423\n\n\nunc-6\n400\n\n\ntra-1\n390\n\n\nlin-4\n386\n\n\nunc-13\n368\n\n\nlin-14\n358\n\n\ngld-1\n355\n\n\nmec-4\n347\n\n\nmpk-1\n343\n\n\ngoa-1\n340\n\n\nunc-5\n328\n\n\nlin-15B\n322\n\n\nlin-39\n321\n\n\ndaf-4\n319\n\n\nglr-1\n316\n\n\npop-1\n308\n\n\nunc-40\n305\n\n\nunc-104\n287\n\n\nhsf-1\n282\n\n\nunc-4\n281\n\n\nced-1\n280\n\n\negl-5\n266\n\n\npar-1\n266\n\n\nlin-28\n265\n\n\ntax-4\n263\n\n\nunc-86\n261\n\n\nlin-17\n258\n\n\nunc-29\n256"
  },
  {
    "objectID": "posts/most_studied_genes/index.html#limitations",
    "href": "posts/most_studied_genes/index.html#limitations",
    "title": "Most studied worm neuronal genes",
    "section": "Limitations",
    "text": "Limitations\nFirst, we are interested in most studied genes, but we only looked at the most cited genes. For example, unc-54 is highly cited, but that may be largely due to its use in transgenes.\nSecond, for annotating tissue types, we rely on the curated expression patterns from Wormbase. Another approach is to use the scRNA-Seq data now available to determine expression patterns. For example, I previously used a thresholding approach to identify neuronal genes, this annotation is available in the minipackage wormDatasets.\nFinally, if we are interested in genes studied for their role in a given tissue (e.g. neurons), we would need a classification of the papers they’re cited in. Here, we rely on (sometimes imprecise) annotations of tissues where a gene is expressed. For example, daf-16 is expressed in neurons, and has been largely studied in all tissues, so it appears as the top hit; that does not necessarily mean it has been studied in neurons that much."
  }
]